CONTROL_SEQUENCE=$'\1'

read_bytes() {
  LANG=C IFS= read -r -d '' -n "$1" char
  printf "%s" "${char}"
}

DATE=$(date +"%a, %d %b %Y %H:%M:%S %Z")
declare -a RESPONSE_HEADERS=(
      "Date: $DATE"
   "Expires: $DATE"
    "Server: Slash Bin Slash Bash"
)

flush_response() {
  # Wait for response code and header "events" from stdin
  local buf
  local code=200
  while true; do
    buf="$(read_bytes "${#CONTROL_SEQUENCE}")"
    #recv "buf: $(printf "%x " "'${buf}") ${#buf}"
    if [ "${buf}" = "${CONTROL_SEQUENCE}" ]; then
      IFS='' read -r line
      line=${line%%$'\r'}
      #recv "line: ${line}"
      local cmd="${line:0:1}"
      local data="${line:1}"
      case "${cmd}" in
        C) code="${data}";;
        H) _add_response_header "${data}";;
      esac
    else
      break
    fi
  done
  send_response_header "${code}"
  printf "%s" "${buf}"
  cat
}

# Set the response status code.
# MUST be called *before* any output is generated by your script.
set_response_code() {
  echo "${CONTROL_SEQUENCE}C$1"
}

# Sets a response header.
# MUST be called *before* any output is generated by your script.
set_response_header() {
  local header="$1"
  shift
  if [ $# -ne 0 ]; then
    header="${header}: $*"
  fi
  echo "${CONTROL_SEQUENCE}H${header}"
}

get_request_header() {
  local name="$1"
  shopt -s nocasematch
  for header in "${REQUEST_HEADERS[@]}"; do
    if [[ "${header}" == "${name}:"* ]]; then
      local index="$((${#name} + 2))"
      echo "${header:$index}"
      return 0
    fi
  done

  # If we got to here then the header was not found
  return 1
}

http_response_parse_body() {
  local length="$(get_request_header "content-length")"
  if [ ! -z "${length}" ]; then
    recv "Reading ${length} byte request body"
    read_bytes "${length}"
  else
    local encoding="$(get_request_header "transfer-encoding")"
    if [ "${encoding}" = "chunked" ]; then
      while IFS='' read -r line; do
        line=${line%%$'\r'}
        #recv "$line"

        length="$(printf "%d" "0x${line%%$'\n'}")"

        if [ "${length}" -gt 0 ]; then
          recv "Reading ${length} byte chunk"
          read_bytes "${length}"

          # The next two bytes are supposed to be '\r\n'
          #recv "Reading 2 byte end"
          # TODO: add verification
          read_bytes 2 > /dev/null
          recv "Done with chunk"
        else
          recv "Done reading chunked body"
          break
        fi
      done
    fi
  fi
}
